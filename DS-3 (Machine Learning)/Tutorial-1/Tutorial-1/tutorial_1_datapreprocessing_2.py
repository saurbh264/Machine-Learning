# -*- coding: utf-8 -*-
"""Tutorial-1_DataPreprocessing-2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1wnPL-ah1FF1v2rD2R8nn6iBndsHdCY4F
"""

from google.colab import drive
drive.mount('/content/drive')

"""# Smoothing Noisy Data using:
## 1. bin means
## 2. bin median
## 3. bin boundaries


"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

df = pd.read_csv('.../daily-min-temperatures.csv')
print(df.columns)

df_ = df[-100:]

date_time = pd.to_datetime(df_['Date'])

temp = np.array(df_['Temp'])

plt.plot(date_time, temp)
plt.gcf().autofmt_xdate()
plt.show()

class binning():
    data = []
    bin_size = 0

    def __init__(self, data, bin_size):
        self.data = data
        self.bin_size = bin_size

    # binning by means
    def binning_means(self):
        sorted_idx = np.argsort(self.data)
        sorted_data = sorted(self.data)
        bins = []
        j=0
        for i in range(0, len(sorted_data), self.bin_size):
            if(i+self.bin_size>=len(sorted_data)):
                bins.append(sorted_data[i:])
            else:
                bins.append(sorted_data[i:i+self.bin_size])
        bins = [[np.mean(i)]*len(i) for i in bins]
        flatten_bins = [q for p in bins for q in p]
        reverted_bins = np.zeros(len(sorted_data))
        for i in range(len(sorted_data)):
            reverted_bins[sorted_idx[i]] = flatten_bins[i]
        return reverted_bins

    # binning by median
    def binning_median(self):
        sorted_idx = np.argsort(self.data)
        sorted_data = sorted(self.data)
        bins = []
        for i in range(0, len(sorted_data), self.bin_size):
            if(i+self.bin_size>=len(sorted_data)):
                bins.append(sorted_data[i:])
            else:
                bins.append(sorted_data[i:i+self.bin_size])
        bins = [[np.median(i)]*len(i) for i in bins]
        flatten_bins = [q for p in bins for q in p]
        reverted_bins = np.zeros(len(sorted_data))
        for i in range(len(sorted_data)):
            reverted_bins[sorted_idx[i]] = flatten_bins[i]
        return reverted_bins

    # binning by boundaries
    def binning_boundaries(self):
        sorted_idx = np.argsort(self.data)
        sorted_data = sorted(self.data)
        bins = []
        for i in range(0, len(sorted_data), self.bin_size):
            bins.append(sorted_data[i:i+self.bin_size])
        for i in range(len(bins)):
            for j in range(len(bins[i])):
                if abs(bins[i][j] - bins[i][0]) < abs(bins[i][j] - bins[i][-1]):
                    bins[i][j] = bins[i][0]
                else:
                    bins[i][j] = bins[i][-1]
        flatten_bins = [q for p in bins for q in p]
        reverted_bins = np.zeros(len(sorted_data))
        for i in range(len(sorted_data)):
            reverted_bins[sorted_idx[i]] = flatten_bins[i]
        return reverted_bins

import matplotlib.pyplot as plt

bin_size = 35
b = binning(temp, bin_size)
mean_binned = b.binning_means()
median_binned = b.binning_median()
boundaries_binned = b.binning_boundaries()

df_binned = pd.DataFrame()
df_binned['Date'] = date_time
df_binned['Temp'] = temp
df_binned['mean_binned'] = np.array(mean_binned).flatten()
df_binned['median_binned'] = np.array(median_binned).flatten()
df_binned['boundaries_binned'] = np.array(boundaries_binned).flatten()
# df_binned.head()
df_binned[:20]

fig = plt.figure(figsize=(12, 10))

sub1 = fig.add_subplot(311) # instead of plt.subplot(2, 2, 1)
sub1.plot(df_binned['Date'], df_binned['Temp'], label='Original')
sub1.plot(df_binned['Date'], df_binned['mean_binned'], label='Mean Binned')
sub1.set_title('Original Temperatures and Mean-smoothed Temperatures')
plt.legend()


sub2 = fig.add_subplot(312)
sub2.plot(df_binned['Date'], df_binned['Temp'], label='Original')
sub2.plot(df_binned['Date'], df_binned['median_binned'], label='Median Binned')
sub2.set_title('Original Temperatures and Median-smoothed Temperatures')
plt.legend()

sub3 = fig.add_subplot(313)
sub3.plot(df_binned['Date'], df_binned['Temp'], label='Original')
sub3.plot(df_binned['Date'], df_binned['boundaries_binned'], label='Boundaries Binned')
sub3.set_title('Original Temperatures and Bin Boundary-smoothed Temperatures')

plt.gcf().autofmt_xdate()
plt.legend()
plt.show()

"""# Standardization and Normalization

"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.preprocessing import MinMaxScaler, StandardScaler

df = pd.read_csv('.../HousePricePrediction.csv')
print(df.columns)

df_ = df[:100]

df_.head()

# Filling NaN values with colum means
df['TotalBsmtSF'].fillna(df['TotalBsmtSF'].mean(), inplace=True)
df['SalePrice'].fillna(df['SalePrice'].mean(), inplace=True)

"""### Data Normalization"""

def min_max_scaling(column):
    min_val = column.min()
    max_val = column.max()
    scaled_column = (column - min_val) / (max_val - min_val)
    return scaled_column

columns_to_normalize = ['LotArea', 'TotalBsmtSF', 'SalePrice']
data_subset = df[columns_to_normalize]
data_normalized = data_subset.apply(min_max_scaling)

"""Data normalization can be done through pre-built library functions also

```
from sklearn.preprocessing import MinMaxScaler

scaler_minmax = MinMaxScaler()
data_normalized = scaler_minmax.fit_transform(data_subset)
data_normalized = pd.DataFrame(data_normalized, columns=columns_to_normalize)
```

Visualizing Lot Area vs SalesPrice
"""

# Scatter plot before normalization
plt.figure(figsize=(12, 6))
plt.subplot(1, 2, 1)
plt.scatter(data_subset['LotArea'], data_subset['SalePrice'], c='b', marker='o', label='Before Scaling')
plt.xlabel('LotArea')
plt.ylabel('SalePrice')
plt.title('Scatter Plot (Before Scaling)')
plt.legend()

# Scatter plot after normalization
plt.subplot(1, 2, 2)
plt.scatter(data_normalized['LotArea'], data_normalized['SalePrice'], c='r', marker='s', label='After Min-Max Scaling')
plt.xlabel('LotArea (Normalized)')
plt.ylabel('SalePrice (Normalized)')
plt.title('Scatter Plot (After Min-Max Scaling)')
plt.legend()

plt.tight_layout()
plt.show()

"""Visualizing TotalBsmtSF vs SalesPrice

"""

# Scatter plot before normalization
plt.figure(figsize=(12, 6))
plt.subplot(1, 2, 1)
plt.scatter(data_subset['TotalBsmtSF'], data_subset['SalePrice'], c='b', marker='o', label='Before Scaling')
plt.xlabel('TotalBsmtSF')
plt.ylabel('SalePrice')
plt.title('Scatter Plot (Before Scaling)')
plt.legend()

# Scatter plot after normalization
plt.subplot(1, 2, 2)
plt.scatter(data_normalized['TotalBsmtSF'], data_normalized['SalePrice'], c='r', marker='s', label='After Min-Max Scaling')
plt.xlabel('TotalBsmtSF (Normalized)')
plt.ylabel('SalePrice (Normalized)')
plt.title('Scatter Plot (After Min-Max Scaling)')
plt.legend()

plt.tight_layout()
plt.show()

# Create a figure with two subplots in one row
fig, axes = plt.subplots(1, 2, figsize=(10, 5))  # 1 row, 2 columns

# Create boxplots on the first subplot
axes[0].boxplot([data_subset['LotArea']], labels=['Before Normalization'])
axes[0].set_ylabel('LotArea')

# Create boxplots on the second subplot
axes[1].boxplot([ data_normalized['LotArea']], labels=['After Normalization'])
axes[1].set_ylabel('LotArea')

# Adjust layout to prevent overlap of labels and titles
plt.tight_layout()

# Show the plots
plt.show()

# Create a figure with two subplots in one row
fig, axes = plt.subplots(1, 2, figsize=(10, 5))  # 1 row, 2 columns

# Create boxplots on the first subplot
axes[0].boxplot([data_subset['TotalBsmtSF']], labels=['Before Normalization'])
axes[0].set_ylabel('TotalBsmtSF')

# Create boxplots on the second subplot
axes[1].boxplot([ data_normalized['TotalBsmtSF']], labels=['After Normalization'])
axes[1].set_ylabel('TotalBsmtSF')

# Adjust layout to prevent overlap of labels and titles
plt.tight_layout()

# Show the plots
plt.show()

# Create a figure with two subplots in one row
fig, axes = plt.subplots(1, 2, figsize=(10, 5))  # 1 row, 2 columns

# Create boxplots on the first subplot
axes[0].boxplot([data_subset['SalePrice']], labels=['Before Normalization'])
axes[0].set_ylabel('SalePrice')

# Create boxplots on the second subplot
axes[1].boxplot([ data_normalized['SalePrice']], labels=['After Normalization'])
axes[1].set_ylabel('SalePrice')

# Adjust layout to prevent overlap of labels and titles
plt.tight_layout()

# Show the plots
plt.show()

"""### Data Standardization"""

def z_score_standardization(column):
    mean_val = column.mean()
    std_dev = column.std()
    standardized_column = (column - mean_val) / std_dev
    return standardized_column

data_standardized = data_subset.apply(z_score_standardization)

"""Data standardisation can be done through pre-built library functions also

```
from sklearn.preprocessing import StandardScaler

scaler_standard = StandardScaler()
data_standardized = scaler_standard.fit_transform(data_subset)
data_standardized = pd.DataFrame(data_standardized, columns=columns_to_normalize)
```

Visualizing Lot Area vs SalesPrice
"""

# Scatter plot before standardization
plt.figure(figsize=(12, 6))
plt.subplot(1, 2, 1)
plt.scatter(data_subset['LotArea'], data_subset['SalePrice'], c='b', marker='o', label='Before Standardizing')
plt.xlabel('LotArea')
plt.ylabel('SalePrice')
plt.title('Scatter Plot (Before Standardizing)')
plt.legend()

# Scatter plot after standardization
plt.subplot(1, 2, 2)
plt.scatter(data_standardized['LotArea'], data_standardized['SalePrice'], c='r', marker='s', label='After Standardizing')
plt.xlabel('LotArea (Standardized)')
plt.ylabel('SalePrice (Standardized)')
plt.title('Scatter Plot (After Standardizing)')
plt.legend()

plt.tight_layout()
plt.show()

"""
Visualizing TotalBsmtSF vs SalesPrice"""

# Scatter plot before standardization
plt.figure(figsize=(12, 6))
plt.subplot(1, 2, 1)
plt.scatter(data_subset['TotalBsmtSF'], data_subset['SalePrice'], c='b', marker='o', label='Before Standardizing')
plt.xlabel('TotalBsmtSF')
plt.ylabel('SalePrice')
plt.title('Scatter Plot (Before Standardizing)')
plt.legend()

# Scatter plot after standardization
plt.subplot(1, 2, 2)
plt.scatter(data_standardized['TotalBsmtSF'], data_standardized['SalePrice'], c='r', marker='s', label='After Standardizing')
plt.xlabel('TotalBsmtSF (Standardized)')
plt.ylabel('SalePrice (Standardized)')
plt.title('Scatter Plot (After Standardizing)')
plt.legend()

plt.tight_layout()
plt.show()

# Create a figure with two subplots in one row
fig, axes = plt.subplots(1, 2, figsize=(10, 5))  # 1 row, 2 columns

# Create boxplots on the first subplot
axes[0].boxplot([data_subset['LotArea']], labels=['Before Standardization'])
axes[0].set_ylabel('LotArea')

# Create boxplots on the second subplot
axes[1].boxplot([data_standardized['LotArea']], labels=['After Standardization'])
axes[1].set_ylabel('LotArea')

# Adjust layout to prevent overlap of labels and titles
plt.tight_layout()

# Show the plots
plt.show()

# Create a figure with two subplots in one row
fig, axes = plt.subplots(1, 2, figsize=(10, 5))  # 1 row, 2 columns

# Create boxplots on the first subplot
axes[0].boxplot([data_subset['TotalBsmtSF']], labels=['Before Standardization'])
axes[0].set_ylabel('TotalBsmtSF')

# Create boxplots on the second subplot
axes[1].boxplot([data_standardized['TotalBsmtSF']], labels=['After Standardization'])
axes[1].set_ylabel('TotalBsmtSF')

# Adjust layout to prevent overlap of labels and titles
plt.tight_layout()

# Show the plots
plt.show()

# Create a figure with two subplots in one row
fig, axes = plt.subplots(1, 2, figsize=(10, 5))  # 1 row, 2 columns

# Create boxplots on the first subplot
axes[0].boxplot([data_subset['SalePrice']], labels=['Before Standardization'])
axes[0].set_ylabel('SalePrice')

# Create boxplots on the second subplot
axes[1].boxplot([data_standardized['SalePrice']], labels=['After Standardization'])
axes[1].set_ylabel('SalePrice')

# Adjust layout to prevent overlap of labels and titles
plt.tight_layout()

# Show the plots
plt.show()

"""# Computing and visualizing the relation between attributes"""

import pandas as pd
import numpy as np

# Importing Dataset from the Location
Data = pd.read_csv( ".../HousePricePrediction.csv" )

# Dropping coloums based on index
# Data.drop(Data.columns[[0, 4, 5, 9, 2]], axis=1, inplace=True)

# Dropping using Specific multiple columns
Data=Data.drop( ['Id','MSZoning','LotConfig','BldgType','Exterior1st'] , axis=1 )

# Selectring Data Frame to work as a covariance matrix
DF = Data[:1460]
print(DF)
DF.shape

# Finding our Covairanve matrix to find Correlation
CovarianceMatrix= DF.cov()
print(CovarianceMatrix)

#Using the covariance matrix to get the correlation matrix
#calculating standard deviation using the diagnol elements of the covariance matrix
std_devs = np.sqrt(np.diag(CovarianceMatrix))
correlation_matrix = CovarianceMatrix / np.outer(std_devs, std_devs)
print(correlation_matrix)

import seaborn as sns
import matplotlib.pyplot as plt

#Heat map of correlation matrix
plt.figure(figsize=(8, 6))
sns.heatmap(correlation_matrix, annot=True, cmap="coolwarm", vmin=-1, vmax=1)
plt.title("Correlation Matrix Heatmap")
plt.show()